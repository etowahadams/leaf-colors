import cv2
from leafcolors import img_help as ih
import re
import json
import numpy as np

rx_dict = {
    'id': re.compile(r'\d+(?=\.jpg)'),
    'detect': re.compile(r'(?<=(\s))(\d+|-\d+)(?=(\s|%|\)))')
}


class LeafColors:
    def __init__(self, darknet_file, img_folder):
        self.darknet = darknet_file
        self.img_folder = img_folder
        self.colors = self.darknet_to_color()

    # ======== FUNCTIONS ========= #
    @staticmethod
    def _parse_line(line):
        """
        For a given line, parses it based on rx_dict, and returns the key and MatchObject if a match was found
        :param line: str line needed to be parsed
        :return: MatchObject, or None if no match was found
        """
        for key, regex in rx_dict.items():
            match = regex.findall(line)
            if match:
                return key, match

        return None, None

    def _parse_file(self):
        """
        Extract the darknet output into a dict
        :return: dict where each key is the image id and the value is a dict of the leaf attributes
        """
        data = {}
        with open(self.darknet, 'r') as file_object:
            line = file_object.readline()
            while line:
                # at each line check for a match with a regex
                key, match = self._parse_line(line)

                if key == 'id':
                    picID = int(match[0])
                    data[picID] = []
                if key == 'detect':
                    leaf_position = {'confidence': int(match[0][1]),
                                     'x': int(match[1][1]),
                                     'y': int(match[2][1]),
                                     'width': int(match[3][1]),
                                     'height': int(match[4][1]),
                                     'rgb': ''}
                    data[picID].append(leaf_position)

                line = file_object.readline()
        return data

    def darknet_to_color(self):
        """
        Finds the color of every leaf in every image
        :return: dict where key is image id and value is array of leaf colors and positions
        """
        results = self._parse_file()
        print('Finding Colors...this might take a while...')
        for pic in results:
            for leaf in results[pic]:
                print(pic)

                img = cv2.imread(self.img_folder + str(pic) + '.jpg')
                bgr = str(ih.get_color(img, leaf))
                # returns a np array, but .tolist() does not work.
                # instead turn into string, [ float float float], and split it
                bgr = re.findall(r'(\d+\.\d+)', bgr)
                bgr.reverse()
                leaf['rgb'] = bgr

        print('Finished finding colors')
        return results

    def get_all_leaf_color(self):
        """
        Getter function for dict generated by darknet_to_color()
        :return: dict where key is image id and value is list of leaf colors and positions
        """
        return self.colors

    def _get_pic_color(self, pic):
        """
        For a given pic dict, return a list of the color of leaves in the image.
        get_pic_color() is used is observation_colors()
        :param pic: dict
        :return: [[R, G, B], [R, G, B]...] rgb tuples
        """
        id = pic['id']
        colors = []
        if self.colors[id]:
            for leaf in self.colors[id]:
                rgb = leaf['rgb']
                if len(rgb) == 3:
                    rgb = [float(val) for val in rgb]  # turn from string into float
                    colors.append(rgb)
        return colors

    def _get_obv_color(self, obv):
        """
        For an observation, returns the dominant color of the observation, based on the dominant color of the leaves
        get_obv_color() is used is observation_colors()
        :param obvs: list of observations
        :return: list [R, G, B] of observation color
        """
        colors = []
        for pic in obv['photos']:
            colors.extend(self._get_pic_color(pic))
        colors = np.float32(colors)

        if len(colors) > 2:
            return self._dom_rgb(colors, 2)
        elif len(colors) == 2:
            return self._dom_rgb(colors, 1)  # takes the average of the two colors
        else:
            colors = colors.tolist()
            return [val for sublist in colors for val in sublist]

    @staticmethod
    def _day_in_year(month, day):
        """
        Returns the cumulative day in the year
        :param month:
        :param day:
        :return: int day out of 365
        """
        months = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30]
        days = day
        for i in range(month - 1):
            days += months[i]
        return days

    @staticmethod
    def _dom_rgb(colors, k):
        """
        For an list of rgb values, gets dominant color
        :param colors: nparray float32
        :param k: k for k-means
        :return: list of dominant color floats, [R, G, B]
        """
        # adapted from Tonechas https://stackoverflow.com/a/43111221
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, .1)
        flags = cv2.KMEANS_RANDOM_CENTERS

        _, labels, palette = cv2.kmeans(colors, k, None, criteria, 10, flags)
        _, counts = np.unique(labels, return_counts=True)

        dominant = palette[np.argmax(counts)]
        dominant = dominant.tolist()
        return dominant

    def observation_colors(self, obvs_file):
        """
        Returns a list of observation dicts, where each observation has a color, location, id, day, week, and observation
        date
        :return:
        """
        with open(obvs_file, 'r') as fp:
            observations = json.load(fp)
        data = []

        for obv in observations:
            print(obv['id'])
            obv_color = self._get_obv_color(obv)
            if obv_color and obv['location']:  # location can be null even though research grade?
                location = obv['location'].split(',')
                location = [float(val) for val in location]
                new_format = {
                    'color': obv_color,
                    'location': location,
                    'id': obv['id'],
                    'observed_on': obv['observed_on'],
                    'day': self._day_in_year(obv['observed_on_details']['month'], obv['observed_on_details']['day']),
                    'week': obv['observed_on_details']['week']
                }
                data.append(new_format)
            print(obv_color)
        return data


if __name__ == '__main__':
    DARKNET_OUTPUT = 'darknetsmall.txt'  # remove the first few irrelevant lines, 'net.optimized_memory = 0 batch = 1...'
    IMG_FOLDER = '2015/'  # folder where the images
    SAVE_FILE = '2015color2.json'

    ana = LeafColors(DARKNET_OUTPUT, IMG_FOLDER)
    with open(SAVE_FILE, 'w+') as fp:
        json.dump(ana.get_all_leaf_color(), fp, sort_keys=True, indent=4)

    with open('2015final2.json', 'w+') as fp:
        json.dump(ana.observation_colors('2015data2.json'), fp, indent=4)
